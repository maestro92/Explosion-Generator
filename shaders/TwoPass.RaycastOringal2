#version 330


out vec4 FragColor;
in vec2 gTexCoord;


uniform sampler2D RayStartPoints;
uniform sampler2D RayStopPoints;
uniform sampler3D Density;
uniform sampler2D DepthMap;
uniform sampler2D Depth_TwoPassFront;
uniform sampler2D Depth_TwoPassBack;

uniform mat4 m_ModelviewProjection;
uniform mat4 m_Modelview;
uniform mat4 m_ViewMatrix;
uniform mat4 m_ProjectionMatrix;
uniform mat4 m_ModelMatrix;

uniform vec3 LightPosition = vec3(1.0, 1.0, 2.0);
uniform vec3 LightIntensity = vec3(10.0);
uniform float Absorption = 1.0;

const float maxDist = sqrt(2.0);	
const int numSamples = 128;
const float stepSize = maxDist/float(numSamples);
const float d_stepSize = 1/float(numSamples);

const int numLightSamples = 2;
//const int numLightSamples = 1;
const float lscale = maxDist / float(numLightSamples);
const float densityFactor = 10;

int TestFlag = 1;

/*
uniform vec3 LightPosition = vec3(0.25,1.0,3);
uniform vec3 LightIntensity = vec3(15);
uniform float Absorption = 1.0;

const float densityFactor = 5;
*/


float zFar = 1000;
float zNear = 1;

float CalcDepthValue(vec3 Depth_Vertex)
{
    vec4 Clip_DepthPosition = m_ModelviewProjection * vec4(Depth_Vertex,1.0);
    float depthValue = Clip_DepthPosition.z / Clip_DepthPosition.w;
    return (depthValue + 1.0) * 0.5;
}


void main()
{
    // range [-1:1, -1:1, -1:1]
    vec3 rayStart = texture(RayStartPoints, gTexCoord).xyz;
    vec3 rayStop = texture(RayStopPoints, gTexCoord).xyz;
    vec3 rayStart_NDC = texture(RayStartPoints, gTexCoord).xyz;
    vec3 rayStop_NDC = texture(RayStopPoints, gTexCoord).xyz;

    vec3 currentDepth = texture(DepthMap, gTexCoord).xyz;
    vec3 TwoPassFront_Depth = texture(Depth_TwoPassFront, gTexCoord).xyz;
    vec3 TwoPassBack_Depth = texture(Depth_TwoPassBack, gTexCoord).xyz;

    float Regular_Depth = texture(DepthMap, gTexCoord.xy).r;
    float TwoPassFront_R_Depth = texture(Depth_TwoPassFront, gTexCoord.xy).r;
    float TwoPassBack_R_Depth = texture(Depth_TwoPassBack, gTexCoord.xy).r;


    if (rayStart == rayStop)
    {
   //     FragColor = vec4(1);
   //     FragColor = vec4(0,0,0.5,0);
        FragColor = vec4(0.2,0.2,0.2,0);
        return;
    }





    // NDC is from -1 - 1
    // texture coordinates 0 - 1

    // converting from NDC to texture coordinates
    rayStart = 0.5 * (rayStart + 1.0);
    rayStop = 0.5 * (rayStop + 1.0);

    vec3 pos = rayStart;
    vec3 step = normalize(rayStop-rayStart) * stepSize;
//    vec3 step = normalize( (m_Modelview * vec4(rayStop,1.0) - m_Modelview * vec4(rayStart,1.0)).xyz) * stepSize;
    
    float travel = distance(rayStop, rayStart); // the depth each pixel will traverse
    float T = 1.0;			// transparency
    vec3 Lo = vec3(0.0);	// iniital color

    vec3 d_pos = rayStart_NDC;



#if 1
    for (int i=0; i < numSamples && travel > 0.0; ++i, pos += step, travel -= stepSize) 
    {
    	// grab the 3D texture density
        float density = texture(Density, pos).x * densityFactor;

        // change texture coord back to NDC coord
        d_pos = 2*pos - 1.0;


        // we do our depth test
        if (TestFlag == 1)
        {
            // compare depth value of smoke with object depth
            if ( density > 0.000 && (Regular_Depth < CalcDepthValue(d_pos)))
            {
                FragColor = vec4(0.2,0.2,0.2,0);
                return; 
            }
            
            // if there are smoke in front of the Objects, we no longer do any depthTest
            else if (density > 0.000 && (Regular_Depth >= CalcDepthValue(d_pos)))
            {
                TestFlag = 0;
            }
        }

        else
        {
            if( Regular_Depth < CalcDepthValue(d_pos))
            {
                T *= 1.0-density*stepSize*Absorption;
                if (T <= 0.01)
                    break;
                float Tl = 1.0;
                vec3 Li = LightIntensity*Tl;
                Lo += Li*T*density*stepSize;
                FragColor.rgb = Lo;
                FragColor.a = 1-T;
                return;
            }
        }



        if (density <= 0.0) 
        {
            continue;
        }


        // the absorption function is the probability that a photon traveling over a unit distance is lost by absorption
        T *= 1.0-density*stepSize*Absorption;

        // if the composite transparency falls below a threshold, we quit
        // since the color is no longer transparent, so it won't change much
        if (T <= 0.01)
            break;

        // vec3 lightDir = normalize(LightPosition-pos)*lscale;
        float Tl = 1.0;

        /*
        vec3 lpos = pos + lightDir;

        for (int s=0; s < numLightSamples; ++s) 
        {
        	// light density
            float ld = texture(Density, lpos).x;
            Tl *= 1.0-Absorption*lscale*ld;
            if (Tl <= 0.01) 
            lpos += lightDir;
        }
*/
        vec3 Li = LightIntensity*Tl;
        Lo += Li*T*density*stepSize;

      //  d_pos += d_step;
      //  pos += step;
      //  travel -= stepSize;
    }

    FragColor.rgb = Lo;
    FragColor.a = 1-T;

   // FragColor = vec4(1,0,0,1);
 #endif
}


